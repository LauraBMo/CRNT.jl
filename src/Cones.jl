
export
    NonnegativeNullspaceCone,
    pRoots_qPossitive,
    Newtonpolytope,
    IntPointIncone

## Nemo: matrix, FlintZZ, nullspace
## Polymake: polytope:cone,intersection
## LinearAlgebra: I

## The nonnegative orthant as a cone
function cone_positiveorthant(n)
    rays = Matrix(I, n, n)
    return Polymake.polytope.Cone(INPUT_RAYS=rays)
end

## The vector space generated by cols of M as a cone
function cone_vectorspace(M)
    rays = transpose(hcat(M, -M))
    return Polymake.polytope.Cone(INPUT_RAYS=rays[:,:])
end

function Nemo.nullspace_right_rational(N::AbstractArray{T}) where T
    Nnemo = Nemo.matrix(Nemo.FlintZZ, N)
    r, U = Nemo.nullspace_right_rational(Nnemo)
    return T.(Array(U[:,1:r]))
end

function convert_to_integers(M)
    mat = Polymake.@convert_to Matrix{Integer} M
    return Int.(transpose(Array(mat)))
end

"""

    NonnegativeNullspaceCone(N::AbstractMatrix{T}) where {T<:Integer}

Return a matrix whose columns generate the cone
intersection of the nonnegative orthant and the nullsapce of `N`.

# Examples
```jldoctest; setup = :(using CRNT)
julia> NonnegativeNullspaceCone([0 0; 0 0])
2×2 Array{Int64,2}:
 1  0
 0  1

julia> NonnegativeNullspaceCone([1 -1; 2 -2])
2×1 Array{Int64,2}:
 1
 1
```
"""
function cone_positivenullspace(N::AbstractMatrix{T}) where {T <: Integer}
    nullspace = Nemo.nullspace_right_rational(N)
    cone = Polymake.polytope.intersection(cone_positiveorthant(size(N,2)), cone_vectorspace(nullspace))
    return convert_to_integers(cone.RAYS)
end

function Newtonpolytope(p)
    Exponents = CollectExponent_homovectors(p)
    return Newtonpolytope(Exponents)
end

function NewtonpolytopeVertices(p, polyname="p")
    P = Newtonpolytope(p)
    println("Computing vertices of the Newton polytope $(polyname), it may take some time.\n")
    PV = Polymake.@convert_to Matrix{Integer} P.VERTICES[:,2:end]
    return P, Int.(Array(PV))
end

## Input:  polytope P, vertex v::Int.
## Output: point/vector in the outer normal cone of P at v::Integer.
function IntPointIncone(rays, lincoeff)
    RatPoint = lincoeff*Rational.(Array(rays))
    ## Return the minimal multiple of d with integer coordinates.
    return Int.(abs(lcm(denominator.(RatPoint)))*RatPoint)
end

## Find roots of p for which q is possitive
function pRoots_qPossitive(p, q, nattemps::Integer=10, randbound::Integer=50)
    NPp, VNPp = NewtonpolytopeVertices(p)
    NPq, VNPq = NewtonpolytopeVertices(q, "q")
    println("Vertices of the Newton polytopes computed!!!!\n")
#     P = NPq
    #     idx = posVq
    # else
    #     Cones = [Polymake.polytope.normal_cone(NPq, v-1, outer=1) for v in posVq]
    #     P = NPp
    #     idx = negVp
    #     ## Flip matrices of vertices to homogenize printing (the indices are flip)
    #     aux = VNPp
    #     VNPp = VNPq
    #     VNPq = aux
    #     end
    for i in posVq
        println("Computing cone to the $(i)th positive vertex of q\n")
        c1 = Polymake.polytope.normal_cone(NPq, i-1, outer=1)
        for (nc2, c2) in enumerate(Conesp)
            rays = Polymake.polytope.intersection(c1,c2).RAYS
            r = size(rays, 1)
            if r > 0
                println("Intersecting cones found :)")
                found = false
                point = IntPointIncone(rays, ones(Int, 1, r))
                println("Computing real positive roots\n")
                proots = CollectallPossitiveRoots(p, point)
                qvals = [Float64(evaluate(q, (Nemo.fmpq).(pt))) for pt in proots]
                if findfirst(>(0), qvals) == nothing
                    j = 1;
                    while !found && j<nattemps
                        j += 1
                        println("Computing point in cone\n")
                        point = IntPointIncone(rays, rand(1:randbound, 1, r))
                        println("Computing real positive roots\n")
                        proots = CollectallPossitiveRoots(p, point)
                        qvals = [Float64(evaluate(q, (Nemo.fmpq).(pt))) for pt in proots]
                        found = findfirst(>(0), qvals) != nothing
                    end
                end
                if found
                    printfound(VNPp[negVp[nc2],:], VNPq[i,:], point, proots, qvals)
                end
            end
        end
    end
end


function printfound(Vp, Vq, point, proots, qvals)
    print("==============================================\n")
    print("==============================================\n")
    print("==============  Points found  ================\n")
    print("Negative Vertex p\n")
    print("$(Vp)\n")
    print("Possitive Vertex q\n")
    print("$(Vq)\n")
    print("Point in both outer normal cones\n")
    print("$(point)\n")
    for j in findall(>(0), qvals)
        print("$(proots[j])\n")
    end
end

function pRoots_qPossitive(p, NPp, VNPp, q, NPq, VNPq, nattemps::Integer=10, randbound::Integer=50)
    println("Finding negative/possitive vertices\n")
    isneg(x) = x<0
    ispos(x) = 0<x
    negVp = Findallrows(isneg, p, VNPp)
    posVq = Findallrows(ispos, q, VNPq)
    println("Computing cones to negative vertices of p\n")
    Conesp = [Polymake.polytope.normal_cone(NPp, v-1, outer=1) for v in negVp]
    Listpt = []
    for i in posVq
        print("==============================================\n")
        print("==============================================\n")
        println("Computing the cone to the $(i)th positive vertex of q\n")
        c1 = Polymake.polytope.normal_cone(P, i-1, outer=1)
        for (nc2, c2) in enumerate(Conesp)
            # print("==============================================\n")
            # print("==============================================\n")
            # println("Intersecting the $(nc2) first cone and the $i second\n")
            rays = Polymake.polytope.intersection(c1,c2).RAYS
            r = size(rays, 1)
            if r > 0
                # println("Intersecting cones found :)")
                found = false
                # println("Computing point in cone (coeffs 1)\n")
                point = IntPointIncone(rays, ones(Int, 1, r))
                # print("Point in both outer normal cones\n")
                # print("$(point)\n")
                # println("Computing real positive roots\n")
                proots = CollectallPossitiveRoots(p, point)
                qvals = [Float64(Nemo.evaluate(q, (Nemo.fmpq).(vec(pt)))) for pt in proots]
                pvals = [Float64(Nemo.evaluate(p, (Nemo.fmpq).(vec(pt)))) for pt in proots]
                found = findfirst(>(0), qvals) != nothing
                if !found
                    j = 1;
                    while !found && j<nattemps
                        j += 1
                        # println("Computing point in cone (rand coeffs, attempt $j)\n")
                        point = IntPointIncone(rays, rand(1:randbound, 1, r))
                        # print("Point in both outer normal cones\n")
                        # print("$(point)\n")
                        # println("Computing real positive roots\n")
                        proots = CollectallPossitiveRoots(p, point)
                        qvals = [Float64(Nemo.evaluate(q, (Nemo.fmpq).(vec(pt)))) for pt in proots]
                        pvals = [Float64(Nemo.evaluate(p, (Nemo.fmpq).(vec(pt)))) for pt in proots]
                        # print("Values of p for the roots\n")
                        # print("$(pvals)\n")
                        # print("Values of q for the roots\n")
                        # print("$(qvals)\n")
                        found = findfirst(>(0), qvals) != nothing
                    end
                end
                if found
                    printfound(VNPp[negVp[nc2],:], VNPq[i,:], point, proots, qvals)
                    Listpt = [Listpt; [[proots, qvals, pvals, point, VNPp[negVp[nc2],:], VNPq[i,:]]]]
                end
            end
        end
    end
    return Listpt
end
