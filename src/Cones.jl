
export NonnegativeNullspaceCone

## Nemo: matrix, FlintZZ, nullspace
## Polymake: polytope:cone,intersection
## LinearAlgebra: I
"""

    NonnegativeNullspaceCone(N::AbstractMatrix{T}) where {T<:Integer}

Return a matrix whose columns generate the cone
intersection of the nonnegative orthant and the nullsapce of `N`.

# Examples
```jldoctest; setup = :(using CRNT)
julia> NonnegativeNullspaceCone([0 0; 0 0])
2×2 Array{Int64,2}:
 1  0
 0  1

julia> NonnegativeNullspaceCone([1 -1; 2 -2])
2×1 Array{Int64,2}:
 1
 1
```
"""
function NonnegativeNullspaceCone(N::AbstractMatrix{T}) where {T<:Integer}
    ## Migrating to Nemo
    Nnemo = Nemo.matrix(Nemo.FlintZZ,N)
    ## Computing nullsapce
    r, U = Nemo.nullspace_right_rational(Nnemo)
    ## Comming back to julia
    nullsp = T.(Array(U[:,1:r]))
    ## The vector space generated by nullsp as a cone
    rays1 = transpose(hcat(nullsp,-nullsp))
    c1 = Polymake.polytope.Cone(INPUT_RAYS=rays1)
    ## The nonnegative orthant as a cone
    rays2 = Matrix{T}(I, size(N,2), size(N,2))
    c2 = Polymake.polytope.Cone(INPUT_RAYS=rays2)
    ## Compute intersection of c1 c2 and save RAYS
    d = Polymake.polytope.intersection(c1,c2).RAYS
    ## Convert to integers
    d = Polymake.@convert_to Matrix{Integer} d
    ## Return the intersection as a Base.Array matrix of integers
    return T.(transpose(Array(d)))
end

function NewtonPolytope(iter)
    Points = CollectHomoiterInmatrows(iter)
    return Polymake.polytope.Polytope(POINTS=Points)
end

function NewtonPolytope(p::MPolyElem)
    return NewtonPolytope(exponent_vectors(p))
end

## Input:  polytope P, vertex v::Int.
## Output: point/vector in the outer normal cone of P at v::Integer.
function IntPointIncone(rays, lincoeff)
    RatPoint = lincoeff*Rational.(Array(rays))
    ## Return the minimal multiple of d with integer coordinates.
    return Int.(abs(lcm(denominator.(RatPoint)))*RatPoint)
end

function CollectallPossitiveRoots(p, inNormalCone, realtol::Real=1e-7)
    ## Compute exponent of t (to know the minimum in case it is negative).
    texponents = [dot(inNormalCone,exp) for exp in exponent_vectors(p)]
    maxdeg = maximum(texponents)
    mindeg = minimum(texponents)
    ## If mindeg>0 we divide by t^(mindeg), otherwise we multiply.
    ## Both correspond to shift by -mindeg!
    poly = zeros(maxdeg-mindeg+1)
    for (c,i) in zip(coeffs(p),texponents)
        poly[i-mindeg+1] = c
    end
    # mindeg = findfirst(!=(0), poly)
    # roots = PolynomialRoots.roots(BigFloat.(poly[mindeg:end]))
    # roots = PolynomialRoots.roots(poly[mindeg:end])
    roots = PolynomialRoots.roots(poly)
    realposs = filter(>(0), real.(filter(x -> abs(imag(x))<realtol, proots)))
    return [t.^inNormalCone for t in realposs]
end

## Find roots of p for which q is possitive
function pRoots_qPossitive(p, q, nattemps::Integer=10, randbound::Integer=50)
    NPp = NewtonPolytope(p)
    NPq = NewtonPolytope(q)
    println("Computing vertices of the Newton polytopes, it may take some time.\n")
    VNPp = Polymake.@convert_to Matrix{Integer} NPp.VERTICES[:,2:end]
    VNPq = Polymake.@convert_to Matrix{Integer} NPq.VERTICES[:,2:end]
    println("Vertices the Newton polytopes computed!!!!\n")
    negVp = FindallVertices(isnegative, p, VNPp)
    posVq = FindallVertices(ispositive, q, VNPq)
    println("Computing first cones\n")
    if length(negVp) < length(posVq)
        Cones = [Polymake.polytope.normal_cone(NPp, v-1, outer=1) for v in negVp]
        P = NPq
        idx = posVq
    else
        Cones = [Polymake.polytope.normal_cone(NPq, v-1, outer=1) for v in posVq]
        P = NPp
        idx = negVp
        ## Flip matrices of vertices to homogenize printing (the indices are flip)
        aux = VNPp
        VNPp = VNPq
        VNPq = aux
    end
    for i in idx
        println("Computing second cones $i th\n")
        c1 = Polymake.polytope.normal_cone(P, i-1, outer=1)
        for (nc2, c2) in enumerate(Cones)
            rays = Polymake.polytope.intersection(c1,c2).RAYS
            r = size(rays, 1)
            if r > 0
                println("Intersecting cones found :)")
                found = false
                println("Computing point in cone\n")
                point = IntPointIncone(rays, ones(Int, 1, r))
                println("Computing real positive roots\n")
                proots = CollectallPossitiveRoots(p, point)
                qvals = [Float64(evaluate(q, (Nemo.fmpq).(pt))) for pt in proots]
                if findfirst(>(0), qvals) == nothing
                    j = 1;
                    while !found && j<nattemps
                        j += 1
                        println("Computing point in cone\n")
                        point = IntPointIncone(rays, rand(1:randbound, 1, r))
                        println("Computing real positive roots\n")
                        proots = CollectallPossitiveRoots(p, point)
                        qvals = [Float64(evaluate(q, (Nemo.fmpq).(pt))) for pt in proots]
                        found = findfirst(>(0), qvals) != nothing
                    end
                end
                if found
                    printfound(VNPp[negVp[nc2],:], VNPq[i,:], point, proots, qvals)
                end
            end
        end
    end
end

function printfound(Vp, Vq, point, proots, qvals)
    print("==============================================\n")
    print("==============================================\n")
    print("==============  Points found  ================\n")
    print("Negative Vertex p\n")
    print("$(Vp)\n")
    print("Possitive Vertex q\n")
    print("$(Vq)\n")
    print("Point in both outer normal cones\n")
    print("$(point)\n")
    for j in findall(>(0), qvals)
        print("$(proots[j])\n")
    end
end
